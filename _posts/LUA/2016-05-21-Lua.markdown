---
layout: post
title:  "Lua & C++"
categories: 代码
tags: Lua
keywords: Lua
description: 
---
##一、Lua加入工程
#####1)官方下载源码，解压；
#####2)使用VS或XCode或其他IDE新建一个“hello worde”的C++工程；
#####3)将lua源码加入工程目录中，我的测试目录结构如下，
```
├── lua
│   ├── Makefile
│   ├── README
│   ├── doc
│   └── src
├── main.cpp
└── main.lua
```
./lua即为lua源码包解压出来的东西,lua的源码文件在lua/src目录下，将lua/src下的文件除Makefile、lua.c<font color="lightgray">(有一个main函数，这是lua的解释器)</font>、luac.c<font color="lightgray">(lua编译器，编译后的lua脚本可被更高效率的使用)</font>外的其他源码文件都加入到helloworld的工程中，当然，可以在工程中增加一个"luasrc"的文件筛选器，将要加入的lua源码文件都放在该文件筛选器下，便于工程结构的分类管理。
此时在main.cpp中，还未加入lua的引用，先编译一次，应该可以编译通过main.cpp及lua的源码文件。

#####4)将lua引入C++
示例main.cpp，再编译一次，应该可以编译成功，示例程序MyLua可用来执行指定的lua脚本的文件。
![mian.cpp code](/public/img/Snip20160521_2.png)

##二、变量
###全局(虚拟机对多文件全局)
```
x = 12345
```
就理解为是lua_State的全局变量x，对所有文件都通用。

###本地(虚拟机对单文件局部)（local关键字修饰）
```
local y = 54321
```
就理解为是lua_State在某个文件里的变量y，仅在那个文件中可用。

##三、变量与类型
Lua是动态类型语言，变量不要类型定义,只需要为变量赋值,给变量赋值了什么类型，变量就是什么类型。

例如：
{% highlight lua %}
--变量类型
local boolean bv = 0.0
bv = x > 250
if bv then
    print("bv is ", bv, " true")
else
    print("bv is ", bv, " false")
end

math.randomseed(os.time())  
bv = math.random(500)
 
if bv > 250 then
    print("bv is ", bv, " > 250")
else
    print("bv is ", bv, " <= 250")
end

bv = "bv -> string"
print("bv is ", bv)
--bv = bv + 1				--非法的操作，无法将不能转化为数值的字符串用于算术计算
--print("bv is ", bv)

bv = "0xEF"
print("bv is ", bv)
print(type(bv))				--string

bv = bv + 1					--在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字
print("bv is ", bv)
print(type(bv))				--number

bv = "0xEF"
print("bv is ", bv)
bv = string.format("%s%s", bv, "kkkl")
print("bv is ", bv)
print(type(bv))				--string

bv = "0xEF"
print("bv is ", bv)
print(type(bv))				--string

bv = string.format("%d%s", bv, "kkkl")
print("bv is ", bv)
print(type(bv))				--string
{% endhighlight %}

结果：
{% highlight bash %}
bv is 	false	 false
bv is 	231	 <= 250
bv is 	bv -> string
bv is 	0xEF
string
bv is 	240.0
number
bv is 	0xEF
bv is 	0xEFkkkl
string
bv is 	0xEF
string
bv is 	239kkkl
string
{% endhighlight %}

##四、控制语句
###if判断
{% highlight lua %}
math.randomseed(os.time())  
x = math.random(500)
print("x is", x)

if x < 100 then
    print("x ∈ [0, 100)")
elseif x < 200 then
    print("x ∈ [100, 200)")
elseif x == 250 then
    print("中彩票了，250")
elseif x < 300 then
    print("x ∈ [200, 250)U(250, 300)")
elseif x < 400 then
    print("x ∈ [300, 400)")
elseif x < 500 then
    print("x ∈ [400, 500)")
elseif x == 500 then
    print("x == 500")
else
    print("x is ", x)
end
{% endhighlight %}
###for循环 
{% highlight lua %}
for i = 0, 1, 0.1 do
    print("for: i is", i)
end
{% endhighlight %}
###while循环
{% highlight lua %}
i = 1.1
while i < 2 do
    print("while: i is ", i)
    i = i + 0.1
end
{% endhighlight %}
###repeat循环
{% highlight lua %}
i = 2.0
repeat 
    print("repeat: i is ", i)
    i = i + 0.1
until i > 3
{% endhighlight %}

##五、表、元表、元方法
万能的表，表之于LUA的地位应该就相当于类之于C++了吧，之前在理解元表与元方法上还有许多模糊的地方。看视频教材，也没有说的很清楚，遂决定抛弃视频教材，还是看看官方的手册比较靠谱点。
<br/>表、元表、元方法的关系简单理解应该就是，元表中定义了元方法，或者说元方法就是元表的元素，表使用setmetatable关联元表，表就可以调用元表中的元方法了，而元表的本质也还是表，所以任意表都可以做元表，包括表做自己的元表，可见元表应该是一个相对的概念。
<br/>剩下需要重点学习一下的就是元方法了。
####操作符"重载"的元方法
```
__add	-- function (a, b)		--对应 + 操作符, a + b
__sub	-- function (a, b)		--对应 - 操作符, a - b
__mul	-- function (a, b)		--对应 * 操作符, a * b
__div	-- function (a, b)		--对应 / 操作符, a / b
__unm	-- function (a)			--对应 -(相反数)操作符, -a
__mod	-- function (a, b)		--对应 % 取模操作符, a % b
__pow	-- function (a, b)		--对应 ^ 乘幂操作符, a ^ b
__call	-- function (tbl, ...)	--对应 () 操作符, tbl(...)

__eq	-- function (a, b)	--对应 == 操作符, t1 == t2
__lt	-- function (a, b)	--对应 < 操作符, t1 < t2
__le	-- function (a, b)	--对应 <= 操作符 t1 <= t2
```

####库定义的元方法
```
__tostring		-- function (tbl) --例如print(tbl) 时，若tbl的元表中定义了__tostring元方法，则自动调用该元方法取自定义的tostring结果(与java中tostring目的相同)
__metatable		-- 给__metatable赋值后，再对主表setmetatable其他元表时会报错，保护主表的元表不被改变，getmetatable会返回__metatable字段值，隐藏元表
```
####table访问/赋值的元方法
```
__index		-- table变量或function (tbl, key)		-- tbl[key]不存在时，将调用__index获取tbl[key]的返回值(mt.__index = mt,结果即为tbl[key]不存在时就取mt[key]做tbl[key]的值)
__newindex	-- table变量或function (tbl, key, val)	-- 赋值val给tbl[key]时，若tbl[key]不存在，则会调用__newindex(tbl, key, val)处理替代默认的创建tbl[key]并赋值val的处理
```

{% highlight lua %}
Set = {}

local mt = {}
mt.name = "defaultName"

function Set.new(l)
	local set = {}
	setmetatable(set, mt)
	for k, v in ipairs(l) do
		set[v] = true			--将集合的元素作为key保存，避免查重检验
	end

	return set
end

--求并集
function Set.union(a, b)
	local res = Set.new{}

	for k in pairs(a) do
		res[k] = true
	end

	for k in pairs(b) do
		res[k] = true
	end

	return res
end

--求交集
function Set.intersection(a, b)
	local res = Set.new{}
	for k in pairs(a) do
		res[k] = b[k]		--只有a[k]、b[k]都不是nil时，res[k]才不是nil
	end

	return res
end

function Set.tostring(set)
	local l = {}

	for k in pairs(set) do
		l[#l + 1] = k
	end

	return "{" .. table.concat(l, ", ") .. "}"
end

function Set.print(s)
	print(Set.tostring(s))
end

s1 = Set.new{10, 20, 30, 50}
s2 = Set.new{30, 1}
print(mt)
print("s1的元表", getmetatable(s1))
print("s2的元表", getmetatable(s2))
Set.print(s1)
Set.print(s2)

--算术类元方法
mt.__add = Set.union
Set.print(s1 + s2)

mt.__mul = Set.intersection
Set.print((s1+s2)*s1)

--关系类元方法
-- <=
mt.__le = function (a, b)
	for k in pairs(a) do
		if not b[k] then
			return false	--如果a中有，b中没有就返回false
		end
	end

	return true	--a中有的，b中都有，则认为a <= b
end

-- <
mt.__lt = function (a, b)
	return a <= b and not(b <= a)
end

-- ==
mt.__eq = function (a, b)
	return a <= b and b <= a
end

print(s1 < s2, s2 > s1)
print(s1 <= s2, s2 >= s1)
print(s1 == s2)
print(s1*s2 <= s1+s2)
print(s1*s2 < s1+s2)

--库定义的元方法
mt.__tostring = Set.tostring
print(s1, s2, s1+s2, s1*s2)

mt.__metatable = "not your business"
print(getmetatable(s1)) --设置了__metatable后，getmetatable会返回该字段值，隐藏元表
--setmetatable(s1)		--设置了__metatable后，setmetatable会报错，保护元表

--table访问的元方法
mt.__index = mt
--mt.__index = function (table, key)
--	return mt[key]
--end

s1.name = "s1 table"
s2.name = "s2 table"

print(s1.name, s2.name)
print(s2.name, s1.name)
{% endhighlight %}

##六、类
实际lua中应该没有类的类型定义，而是使用表和元表的特性来模拟出类的继承等特性，可以面向对象的编程。


##七、与C语言交互



